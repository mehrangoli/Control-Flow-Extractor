#This is a parser to extract static information of a SystemC design from its debug symbol (generated by GDB).
#This information includes names of modules and their member functions, and end point of each function.
#Copyright (c) 2019 Group of Computer Architecture, university of Bremen. All Rights Reserved.
#Filename: DataExtractor.py
#Version 1  09-July-2019
# -- coding: utf-8 --
#!/usr/bin/env python


import re 
from Define import *

class static_data:
	
	def __init__(self):
		try:
			self.symbol_file = open("gdb_symbol.txt",'r')
		except IOError:
			print info_user.FAIL + "Could not find \"gdb_symbol.txt\" file!" + info_user.ENDC
		self.database_dict = {}
		self.global_func_list = []
		
	
	def module_finder(self):
		for line in self.symbol_file:
			if (((STRUCT in line) or (CLASS in line)) and (SCMODULE in line) and ('::_' not in line) and (BLOCK not in line) and (CONSTRUCT not in line) and ('*' not in line)):
					module_name= module_name_extractor(line)
					func_list=[]
					if (CLASS not in module_name) and (CONST not in module_name) and (SCCORE not in module_name): #----------------ignoring the pre-defined systemc module and function
						func_list = function_finder (self.symbol_file, module_name)
						if module_name not in self.database_dict:
							self.database_dict[module_name] = func_list
							
		
	
	def find_global_func (self):
		self.symbol_file.seek(0)
		for line in self.symbol_file:
			if (BLOCK in line) and (SCMAIN in line):
				break
			elif (BLOCK in line) and ('::' not in line) and ('function' in line) and (' __' not in line) and (' _' not in line) and ('..' not in line) :
				split_line=line.split()
				func_name = split_line[-1]
				temp=func_name.index('(') #-----------------extract pure name of function
				func_name = func_name[:temp]
				if func_name not in self.global_func_list:
					self.global_func_list.append(func_name)
		
		
	
	def generate_gdb_command (self):
		gdb_source = open("gdb_source_generated.txt",'w')					
		string = 'set logging on gdblog.txt\nset logging redirect on\nset height 0\nset confirm off\n'	
		gdb_source.write(string)
		
		#-----------------------------------------------------------for sc_main..................................--------------------------#
		string = 'tbreak sc_main\ncommands\n\t'
		gdb_source.write(string)
		
		string = '\n\tdisassemble sc_main\n\tinfo line __static_initialization_and_destruction_0(int, int)\n\tc\n'
		gdb_source.write(string)
		
		string = 'end\n\n'
		gdb_source.write(string)
		
		#-------------------------------------------- --------------------------------for global function------------------------------------#
		for func_name in self.global_func_list:
		
			string = 'tbreak %s\ncommands\n\t'%(func_name)
			gdb_source.write(string)
			
			string = '\n\tdisassemble %s\n\tinfo line __static_initialization_and_destruction_0(int, int)\n\tc\n'%(func_name)
			gdb_source.write(string)
			
			string = 'end\n\n'
			gdb_source.write(string)
								
		
		#-------------------------------------------- --------------------------------for other modules---------------------------------------#
		for i in self.database_dict: 
			module_name= i
			for j in self.database_dict[i]:							
				
				string = 'tbreak %s::%s\ncommands\n\t'%(module_name,j)
				gdb_source.write(string)
				
				string = '\n\tdisassemble %s::%s\n\tinfo line __static_initialization_and_destruction_0(int, int)\n\tc\n'%(module_name,j)
				gdb_source.write(string)
				
				string = 'end\n\n'
				gdb_source.write(string)
															
		gdb_source.write('run\n') #--------in case that the function does not have "retq"
		gdb_source.close()		
		
		
		
		

sd_finder = static_data()
sd_finder.module_finder()
sd_finder.find_global_func()
sd_finder.generate_gdb_command()
